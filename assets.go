// Code generated by assets compiler. DO NOT EDIT.

package main

var (
	assets = map[string]string{
		"/changefile.ch": "@x\n@d othercases == others: {default for cases not listed explicitly}\n@y\n@d othercases == else {default for cases not listed explicitly}\n@z\n\n@x\n@!pool_name='TeXformats:TEX.POOL                     ';\n@y\n@!pool_name='tex.pool                                ';\n@z\n",
		"/rtl.go":        "// NOTE: This file (rtl.go) has a different license compared to all of the\n// other Go files in this repository.\n\n// ----------------------------------------------------------------------------\n//\n// No Copyright\n//\n// The person who associated a work with this deed has dedicated the work to\n// the public domain by waiving all of his or her rights to the work worldwide\n// under copyright law, including all related and neighboring rights, to the\n// extent allowed by law.\n//\n// You can copy, modify, distribute and perform the work, even for commercial\n// purposes, all without asking permission. See Other Information below.\n//\n// This license is acceptable for Free Cultural Works.\n//\n// Other Information\n//\n// In no way are the patent or trademark rights of any person affected by CC0,\n// nor are the rights that other persons may have in the work or in how the\n// work is used, such as publicity or privacy rights.\n//\n// Unless expressly stated otherwise, the person who associated a work with\n// this deed makes no warranties about the work, and disclaims liability for\n// all uses of the work, to the fullest extent permitted by applicable law.\n//\n// When using or citing the work, you should not imply endorsement by the\n// author or the affirmer.\n//\n// ----------------------------------------------------------------------------\n// Source of the above: https://creativecommons.org/publicdomain/zero/1.0/\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"unsafe\"\n)\n\ntype memoryWord struct {\n\tvariant float64\n}\n\n/* CUT HERE */\n\nvar (\n\t_ error = pasError(0)\n\n\tisMain bool\n)\n\nconst (\n\tpasEndOfTeX pasError = -iota - 1\n\tpasFinalEnd\n)\n\nconst (\n\tstdioDev      = \"TTY:\"\n\tmodeNoIOPanic = \"/O\"\n)\n\nfunc origin(skip int) string {\n\tpc, fn, fl, _ := runtime.Caller(skip)\n\tfn = filepath.Base(fn)\n\tf := runtime.FuncForPC(pc)\n\tvar fns string\n\tif f != nil {\n\t\tfns = f.Name()\n\t\tif x := strings.LastIndex(fns, \".\"); x > 0 {\n\t\t\tfns = fns[x+1:]\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"%s:%d:%s\", fn, fl, fns)\n}\n\nfunc todo(s string, args ...interface{}) string { //TODO-\n\tswitch {\n\tcase s == \"\":\n\t\ts = fmt.Sprintf(strings.Repeat(\"%v \", len(args)), args...)\n\tdefault:\n\t\ts = fmt.Sprintf(s, args...)\n\t}\n\tpc, fn, fl, _ := runtime.Caller(1)\n\tf := runtime.FuncForPC(pc)\n\tvar fns string\n\tif f != nil {\n\t\tfns = f.Name()\n\t\tif x := strings.LastIndex(fns, \".\"); x > 0 {\n\t\t\tfns = fns[x+1:]\n\t\t}\n\t}\n\tr := fmt.Sprintf(\"%s:%d:%s: TODOTODO %s\", fn, fl, fns, s) //TODOOK\n\tfmt.Fprintf(os.Stdout, \"%s\\n\", r)\n\tos.Stdout.Sync()\n\treturn r\n}\n\nfunc trc(s string, args ...interface{}) string { //TODO-\n\tswitch {\n\tcase s == \"\":\n\t\ts = fmt.Sprintf(strings.Repeat(\"%v \", len(args)), args...)\n\tdefault:\n\t\ts = fmt.Sprintf(s, args...)\n\t}\n\t_, fn, fl, _ := runtime.Caller(1)\n\tr := fmt.Sprintf(\"%s:%d: TRC %s\", fn, fl, s)\n\tfmt.Fprintf(os.Stdout, \"%s\\n\", r)\n\tos.Stdout.Sync()\n\treturn r\n}\n\ntype pasError int\n\nfunc (err pasError) Error() string { return fmt.Sprintf(\"%T(%[1]d)\", err) }\n\nfunc pasJumpOut() { panic(pasEndOfTeX) }\n\nfunc abs(n float32) float32 { return float32(math.Abs(float64(n))) } //TODO check the Pascal definition.\n\nfunc chr(i int32) byte { return byte(i) }\n\nfunc iabs(n int32) int32 {\n\tif n >= 0 {\n\t\treturn n\n\t}\n\n\tif n == math.MinInt32 {\n\t\tpanic(\"overflow\")\n\t}\n\n\treturn -n\n}\n\nfunc odd(i int32) bool { return i&1 != 0 }\n\nfunc round(n float32) int32 { return int32(math.Round(float64(n))) } //TODO check the Pascal definition.\n\nfunc read(args ...interface{})    { args[0].(*pasFile).read(args[1:], false) }\nfunc readLn(args ...interface{})  { args[0].(*pasFile).read(args[1:], true) }\nfunc write(args ...interface{})   { args[0].(*pasFile).write(args[1:], false) }\nfunc writeLn(args ...interface{}) { args[0].(*pasFile).write(args[1:], true) }\n\ntype pasFile struct {\n\t*ioFile\n}\n\nfunc break1(f *pasFile)                      { /* nop */ }\nfunc breakIn(f *pasFile, b bool)             { /* nop */ }\nfunc close(f *pasFile)                       { f.close() }\nfunc eof(f *pasFile) bool                    { return f.ioFile.eof() }\nfunc eoln(f *pasFile) bool                   { return f.ioFile.eoln() }\nfunc erstat(f *pasFile) int32                { return f.erstat() }\nfunc get(f *pasFile)                         { f.get() }\nfunc put(f *pasFile)                         { f.put() }\nfunc reset1(f *pasFile, name, mode string)   { reset(f, 1, name, mode) }\nfunc reset4(f *pasFile, name, mode string)   { reset(f, 4, name, mode) }\nfunc rewrite1(f *pasFile, name, mode string) { rewrite(f, 1, name, mode) }\nfunc rewrite4(f *pasFile, name, mode string) { rewrite(f, 4, name, mode) }\n\nfunc reset(f *pasFile, itemSize int, name, mode string) {\n\tname = strings.TrimRight(name, \" \")\n\tpanicOnError := !strings.Contains(mode, modeNoIOPanic)\n\tf.close()\n\tf.ioFile = nil\n\tif isMain && name == stdioDev {\n\t\tf.ioFile = &ioFile{\n\t\t\titemSize:     itemSize,\n\t\t\tname:         name,\n\t\t\tpanicOnError: panicOnError,\n\t\t\tr0:           os.Stdin,\n\t\t\tr:            bufio.NewReader(os.Stdin),\n\t\t}\n\t\treturn\n\t}\n\n\tg, err := os.Open(name)\n\tif err != nil {\n\t\tif panicOnError {\n\t\t\tf.ioFile = &ioFile{\n\t\t\t\terr:          err,\n\t\t\t\titemSize:     itemSize,\n\t\t\t\tname:         name,\n\t\t\t\tpanicOnError: panicOnError,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tf.ioFile = &ioFile{\n\t\titemSize:     itemSize,\n\t\tname:         name,\n\t\tpanicOnError: panicOnError,\n\t\tr0:           g,\n\t\tr:            bufio.NewReader(g),\n\t}\n}\n\nfunc rewrite(f *pasFile, itemSize int, name, mode string) {\n\tname = strings.TrimRight(name, \" \")\n\tpanicOnError := !strings.Contains(mode, modeNoIOPanic)\n\tf.close()\n\tf.ioFile = nil\n\tif isMain && name == stdioDev {\n\t\tf.ioFile = &ioFile{\n\t\t\titemSize:     itemSize,\n\t\t\tname:         os.Stdout.Name(),\n\t\t\tpanicOnError: panicOnError,\n\t\t\tw:            os.Stdout,\n\t\t}\n\t\treturn\n\t}\n\n\tg, err := os.Create(name)\n\tif err != nil {\n\t\tpanic(todo(\"\"))\n\t}\n\n\tf.ioFile = &ioFile{\n\t\titemSize:     itemSize,\n\t\tname:         name,\n\t\tpanicOnError: panicOnError,\n\t\tw:            g, //TODO bufio?\n\t}\n}\n\nfunc (f *pasFile) byte() byte {\n\tif f.itemSize != 1 {\n\t\tpanic(todo(\"internal error: %v\", f.itemSize))\n\t}\n\n\tif !f.componentMode {\n\t\tf.get()\n\t}\n\n\treturn f.buf[0]\n}\n\nfunc (f *pasFile) memoryWord() memoryWord {\n\tif f.itemSize != 8 {\n\t\tpanic(todo(\"internal error: %v\", f.itemSize))\n\t}\n\n\treturn *(*memoryWord)(unsafe.Pointer(&f.buf[0]))\n}\n\nfunc (f *pasFile) pMemoryWord() *memoryWord {\n\tif f.itemSize != 8 {\n\t\tpanic(todo(\"internal error: %v\", f.itemSize))\n\t}\n\n\treturn (*memoryWord)(unsafe.Pointer(&f.buf[0]))\n}\n\ntype ioFile struct {\n\tr0 *os.File\n\tr  *bufio.Reader\n\tw  io.Writer\n\n\tb1       [1]byte\n\tbuf      [4]byte\n\terr      error\n\titemSize int\n\tname     string\n\n\tcomponentMode bool\n\tpanicOnError  bool\n}\n\nfunc (f *ioFile) close() {\n\tif f == nil {\n\t\treturn\n\t}\n\n\tif x, ok := f.w.(io.Closer); ok {\n\t\tif f.err = x.Close(); f.err != nil && f.panicOnError {\n\t\t\tpanic(fmt.Errorf(\"I/O error: %v\", f.err))\n\t\t}\n\n\t\tf.w = nil\n\t\treturn\n\t}\n\n\tif f.r != nil {\n\t\tif f.err = f.r0.Close(); f.err != nil && f.panicOnError {\n\t\t\tpanic(fmt.Errorf(\"I/O error: %v\", f.err))\n\t\t}\n\n\t\tf.r0 = nil\n\t\tf.r = nil\n\t\treturn\n\t}\n}\n\nfunc (f *ioFile) read(args []interface{}, nl bool) {\n\tfor len(args) != 0 {\n\t\targ := args[0]\n\t\targs = args[1:]\n\t\tif w, ok := getWidth(&args); ok {\n\t\t\tpanic(todo(\"\", w))\n\t\t}\n\n\t\tswitch x := arg.(type) {\n\t\tcase *byte:\n\t\t\tvar n int\n\t\t\tif n, f.err = f.r.Read(f.buf[:1]); n != 1 {\n\t\t\t\tpanic(todo(\"%q %v %v\", f.name, n, f.err))\n\t\t\t}\n\n\t\t\t*x = f.buf[0]\n\t\tdefault:\n\t\t\tpanic(todo(\"%T\", x))\n\t\t}\n\t}\n\tif !nl {\n\t\treturn\n\t}\n\n\tfor {\n\t\tvar n int\n\t\tn, f.err = f.r.Read(f.b1[:])\n\t\tif n == 0 || f.b1[0] == '\\n' {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (f *ioFile) eof() bool {\n\tif f.err == io.EOF {\n\t\treturn true\n\t}\n\n\tvar n int\n\tif n, f.err = f.r.Read(f.b1[:]); n == 0 || f.err == io.EOF {\n\t\treturn true\n\t}\n\n\tf.r.UnreadByte()\n\treturn false\n}\n\nfunc (f *ioFile) eoln() bool {\n\tif f.err == io.EOF {\n\t\treturn true\n\t}\n\n\tif f.componentMode {\n\t\treturn f.buf[0] == '\\n'\n\t}\n\n\tvar n int\n\tif n, f.err = f.r.Read(f.b1[:]); n == 0 || f.err == io.EOF {\n\t\tf.err = io.EOF\n\t\treturn true\n\t}\n\n\tf.r.UnreadByte()\n\treturn f.b1[0] == '\\n'\n}\n\nfunc (f *ioFile) write(args []interface{}, nl bool) {\n\tfor len(args) != 0 {\n\t\targ := args[0]\n\t\targs = args[1:]\n\t\tif w, ok := getWidth(&args); ok {\n\t\t\tpanic(todo(\"\", w))\n\t\t}\n\n\t\tswitch x := arg.(type) {\n\t\tcase string:\n\t\t\tif _, f.err = f.w.Write([]byte(x)); f.err != nil && f.panicOnError {\n\t\t\t\tpanic(fmt.Errorf(\"I/O error: %v\", f.err))\n\t\t\t}\n\t\tcase byte:\n\t\t\tf.buf[0] = x\n\t\t\tif _, f.err = f.w.Write(f.buf[:1]); f.err != nil && f.panicOnError {\n\t\t\t\tpanic(fmt.Errorf(\"I/O error: %v\", f.err))\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(todo(\"%T\", x))\n\t\t}\n\t}\n\tif nl {\n\t\tif _, f.err = f.w.Write([]byte(\"\\n\")); f.err != nil && f.panicOnError {\n\t\t\tpanic(fmt.Errorf(\"I/O error: %v\", f.err))\n\t\t}\n\t}\n}\n\nfunc (f *ioFile) get() {\n\tf.componentMode = true\n\tvar n int\n\tif n, f.err = f.r.Read(f.buf[:f.itemSize]); n != f.itemSize && f.panicOnError {\n\t\tpanic(fmt.Errorf(\"I/O error: %v\", f.err))\n\t}\n}\n\nfunc (f *ioFile) put() {\n\tvar n int\n\tif n, f.err = f.w.Write(f.buf[:f.itemSize]); n != f.itemSize && f.panicOnError {\n\t\tpanic(fmt.Errorf(\"I/O error: %v\", f.err))\n\t}\n}\n\nfunc (f *ioFile) erstat() int32 {\n\tif f.err == nil {\n\t\treturn 0\n\t}\n\n\treturn 1\n}\n\ntype vaWidth int\n\nfunc getWidth(args *[]interface{}) (int, bool) {\n\ts := *args\n\tif len(s) == 0 {\n\t\treturn 0, false\n\t}\n\n\tx, ok := s[0].(vaWidth)\n\tif !ok {\n\t\treturn 0, false\n\t}\n\n\t*args = s[1:]\n\treturn int(x), true\n}\n",
	}
)

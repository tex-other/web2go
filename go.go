// Copyright 2021 The web2go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main // import "modernc.org/web2go"

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
)

const ( // tex.pdf pg.5, ยง6
	endOfTeX = "9998"
	finalEnd = "9999"
)

type project struct {
	errs      []string
	nextLabel int
	out       io.Writer
	task      *task

	closed bool
}

func newProject(t *task) *project {
	return &project{
		task: t,
	}
}

func (p *project) newLabel() int {
	r := p.nextLabel
	p.nextLabel++
	return r
}

func (p *project) err(n node, msg string, args ...interface{}) {
	if !p.task.e && len(p.errs) == 10 {
		return
	}

	pos := "-: "
	if n != nil {
		pos = fmt.Sprintf("%v: ", n.Position())
	}
	msg = fmt.Sprintf(pos+msg, args...)
	if s := strings.ToLower(msg); strings.Contains(s, "internal error") || strings.Contains(s, "todo") {
		msg += fmt.Sprintf(" (%v)", origin(2))
	}
	p.errs = append(p.errs, msg)
}

func (p *project) w(s string, args ...interface{}) {
	if p.closed {
		return
	}

	if _, err := fmt.Fprintf(p.out, s, args...); err != nil {
		p.err(nil, "%s", err)
		p.closed = true
	}
}

func (p *project) main(program *program) (err error) {
	defer func() {
		if len(p.errs) != 0 {
			err = fmt.Errorf("%s", strings.Join(p.errs, "\n"))
		}
	}()

	f, err := os.Create(p.task.o)
	if err != nil {
		p.err(nil, "%s", err)
		return
	}

	defer func() {
		if err := f.Close(); err != nil {
			p.err(nil, "%s", err)
			return
		}

		if out, err := exec.Command("gofmt", "-s", "-w", p.task.o).CombinedOutput(); err != nil {
			p.err(nil, "%s\n%s", out, err)
		}
	}()

	buf := bufio.NewWriter(f)

	defer func() {
		if err := buf.Flush(); err != nil {
			p.err(nil, "%s", err)
		}
	}()

	p.out = buf
	p.w("// Code generated by %v, DO NOT EDIT.\n\n", p.task.args)
	for _, v := range p.task.copyright {
		p.w("\n// %s", v)
	}
	s := ""
	if !p.task.lib {
		s = "\t\"runtime/debug\"\n\t"
	}
	p.w(`
package %s

import (
	"fmt"
	"io"
	"math"
	"os"
	"path/filepath"
	"runtime"
%s	"strings"
	"time"
	"unsafe"
)

`, p.task.pkgName, s)
	p.block(program.block, true)
	rtl := assets["/rtl.go"]
	const tag = "/* CUT HERE */"
	rtl = rtl[strings.Index(rtl, tag)+len(tag):]
	rtl = strings.ReplaceAll(rtl, "TYPE", "tex")
	p.w("\n\n// Run time library\n\n%s", rtl)
	return
}

func (p *project) block(n *block, tld bool) {
	p.constantDefinitionPart(n.constantDefinitionPart)
	p.typeDefinitionPart(n.typeDefinitionPart)
	p.variableDeclarationPart(n.variableDeclarationPart, tld)
	for _, v := range n.list {
		p.procedureAndFunctionDeclarationPart(v)
	}
	p.nextLabel = 0
	p.compoundStatement(n.compoundStatement, tld, false, true)
}

func (p *project) compoundStatement(n *compoundStatement, tld, braces, braced bool) {
	if tld {
		switch {
		case p.task.lib:
			p.w("\n\nfunc (%s *%s) main() {", p.task.rcvrName, p.task.progTypeName)
		default:
			p.w(`

func main() {
	isMain = true
	defer func() {
		switch err := recover(); x := err.(type) {
		case nil:
			// nop
		case pasError:
			switch x {
			case pasFinalEnd, pasEndOfTeX:
				// ok
			}
		default:
			fmt.Fprintln(os.Stderr, err)
			fmt.Fprintf(os.Stderr, "%%s\n", debug.Stack())
			os.Exit(1)
		}
	}()
`)
		}
		defer p.w("\n}")
	}
	if braces {
		p.w("\n{")
		defer p.w("\n}")
	}
	for _, v := range n.list {
		p.statement(v, braced)
	}
}

func (p *project) statement(n *statement, braced bool) {
	var s string
	if !braced {
		s = "\n"
	}
	if n.label != nil {
		switch n.label.src {
		case endOfTeX, finalEnd:
			// nop
		default:
			p.w("%s", s)
			s = ""
			p.w("%s:", p.label(n.label))
		}
	}
	if n.simpleStatement != nil {
		if n.simpleStatement.isEmpty {
			return
		}

		p.w("%s", s)
		p.simpleStatement(n.simpleStatement)
		p.w(";")
		return
	}

	p.w("%s", s)
	p.structuredStatmenent(n.structuredStatmenent, braced)
	p.w(";")
}

func (p *project) label(n *tok) string {
	return "label" + n.src
}

func (p *project) structuredStatmenent(n *structuredStatmenent, braced bool) {
	if n.repetitiveStatement != nil {
		p.repetitiveStatement(n.repetitiveStatement)
		return
	}

	if n.compoundStatement != nil {
		p.compoundStatement(n.compoundStatement, false, !braced, braced)
		return
	}

	p.conditionalStatement(n.conditionalStatement)
}

func (p *project) conditionalStatement(n *conditionalStatement) {
	if n.caseStatement != nil {
		p.caseStatement(n.caseStatement)
		return
	}

	p.ifStatement(n.ifStatement)
}

func (p *project) ifStatement(n *ifStatement) {
	p.w("if ")
	p.expression(n.expression, aBoolean, false)
	p.w(" {")
	p.statement(n.statement, true)
	p.w("\n}")
	if n.else_ == nil {
		return
	}

	switch {
	case n.elseStatement.isIf:
		p.w(" else ")
		p.statement(n.elseStatement, false)
	default:
		p.w(" else {")
		p.statement(n.elseStatement, true)
		p.w("\n}")
	}
}

func (p *project) caseStatement(n *caseStatement) {
	p.w("switch ")
	p.expression(n.expression, n.expression.typ, false)
	p.w(" {")
	for _, v := range n.list {
		p.case_(v)
	}
	p.w("\n}")
}

func (p *project) case_(n *case_) {
	switch {
	case n.elseTok != nil:
		p.w("\ndefault")
	default:
		p.w("\ncase")
		for i, v := range n.list {
			if i != 0 {
				p.w(",")
			}
			p.w(" %s", v.literal.render())
		}
	}
	p.w(":")
	p.statement(n.statement, true)
}

func (p *project) repetitiveStatement(n *repetitiveStatement) {
	if n.forStatement != nil {
		p.forStatement(n.forStatement)
		return
	}

	if n.whileStatement != nil {
		p.whileStatement(n.whileStatement)
		return
	}

	p.repeatStatement(n.repeatStatement)
}

func (p *project) repeatStatement(n *repeatStatement) {
	p.w("for {")
	for _, v := range n.list {
		p.statement(v, len(n.list) == 1)
	}
	p.w("\nif ")
	p.expression(n.expression, aBoolean, false)
	p.w(" {\nbreak\n}\n}")
}

func (p *project) whileStatement(n *whileStatement) {
	p.w("for ")
	p.expression(n.expression, aBoolean, false)
	p.w(" {")
	p.statement(n.statement, true)
	p.w("\n}")
}

func (p *project) forStatement(n *forStatement) {
	p.w("for _i := int64(")
	p.expression(n.initial, n.initial.typ, false)
	p.w("); _i")
	var s string
	switch n.toOrDownto.ch {
	case TO:
		p.w(" <= int64(")
		p.expression(n.final, n.final.typ, false)
		s = "++"
	default:
		p.w(" >= int64(")
		p.expression(n.final, n.final.typ, false)
		s = "--"
	}
	p.w("); _i%s {", s)
	if x, ok := n.identifier.def.(*variableDeclaration); ok {
		if _, ok := x.used[n.identifier.src]; ok {
			p.identifier(n.identifier)
			p.w(" = %s(_i);", n.identifier.typ.goType())
		}
	}
	p.statement(n.statement, true)
	p.w("\n}")
}

func (p *project) simpleStatement(n *simpleStatement) {
	if n.assignmentStatement != nil {
		p.assignmentStatement(n.assignmentStatement)
		return
	}

	if n.procedureStatement != nil {
		p.procedureStatement(n.procedureStatement)
		return
	}

	if n.gotoStatement != nil {
		p.gotoStatement(n.gotoStatement)
	}
}

func (p *project) gotoStatement(n *gotoStatement) {
	switch n.label.src {
	case endOfTeX:
		p.w("panic(pasEndOfTeX)")
	case finalEnd:
		p.w("panic(pasFinalEnd)")
	default:
		p.w("goto %s", p.label(n.label))
	}
}

func (p *project) procedureStatement(n *procedureStatement) {
	switch def := n.identifier.def.(*procedureDeclaration); {
	case def.isRead:
		p.identifier(n.identifier)
		p.w("(")
		defer p.w(")")
		for i, v := range n.list {
			if i != 0 {
				p.w("&")
			}
			p.arg(v)
			p.w(", ")
		}
	case def.isWrite:
		p.identifier(n.identifier)
		p.w("(")
		defer p.w(")")
		for _, v := range n.list {
			p.arg(v)
			p.w(", ")
		}
	default:
		p.identifier(n.identifier)
		if def.isResetOrRewrite {
			p.w("%d", n.list[0].typ.(*file).component.size())
		}
		p.w("(")
		defer p.w(")")
		args := def.procedureHeading.args
		for i, v := range n.list {
			p.expression(v.expression, args[i], false)
			p.w(", ")
		}
	}
}

func (p *project) arg(n *arg) {
	p.expression(n.expression, n.expression.typ, false)
	if n.width == nil {
		return
	}

	p.w(", vaWidth(")
	p.expression(n.width, n.width.typ, false)
	p.w(")")

	if n.width2 == nil {
		return
	}

	p.w(", vaWidth(")
	p.expression(n.width2, n.width2.typ, false)
	p.w(")")
}

func (p *project) assignmentStatement(n *assignmentStatement) {
	switch lt := n.variable.typ.(type) {
	case *array:
		switch rt := n.expression.typ.(type) {
		case *array:
			if lt.canBeAssignedFrom(rt) {
				if rt.isString {
					p.w("setString(")
					p.rVariable(n.variable)
					p.w("[:], ")
					p.expression(n.expression, n.variable.typ, false)
					p.w(")")
					return
				}

				panic(todo(""))
			}

			panic(todo(""))
		}
	}

	if fld := n.variable.field; fld != nil && fld.isVariant || n.variable.deref != nil {
		p.w("*")
	}
	if p.lVariable(n.variable) {
		p.w(" = ")
	}
	p.expression(n.expression, n.variable.typ, false)
}

func (p *project) lVariable(n *variable) (used bool) {
	if n.identifier != nil {
		switch n.identifier.def.(type) {
		case *functionDeclaration:
			p.w("ret")
		default:
			if !n.identifier.scope.isTLD {
				if x, ok := n.identifier.def.(*variableDeclaration); ok {
					if _, ok := x.used[n.identifier.src]; !ok {
						return false
					}
				}
			}

			p.identifier(n.identifier)
		}
		return true
	}

	if n.componentVariable != nil {
		p.lComponentVariable(n.componentVariable)
		return true
	}

	p.lDeref(n.deref)
	return true
}

func (p *project) lDeref(n *variable) {
	p.lVariable(n)
	p.w(".%s()", p.lvalueName(n.typ.(*file).component.goType()))
}

func (p *project) lComponentVariable(n *componentVariable) {
	if n.indexedVariable != nil {
		p.lIndexedVariable(n.indexedVariable)
		return
	}

	p.lFieldDesignator(n.fieldDesignator)
}

func (p *project) lFieldDesignator(n *fieldDesignator) {
	p.lVariable(n.variable)
	switch {
	case n.field.isVariant:
		p.w(".%s()", p.lvalueName(n.ident.src))
	default:
		p.w(".%s", goIdent(n.ident.src))
	}
}

func (p *project) lIndexedVariable(n *indexedVariable) {
	p.lVariable(n.variable)
	dims := n.variable.typ.(*array).dims
	for i, v := range n.list {
		p.w("[")
		p.expression(v, v.typ, false)
		if x, ok := dims[i].(*subrange); ok && x.lo != 0 {
			p.w("%+d", -x.lo)
		}
		p.w("]")
	}
}

func (p *project) expression(n *expression, t typ, parens bool) {
	if n.relOp == nil {
		param := false
		if id := n.identifier; id != nil {
			_, param = id.def.(*variableParameterSpecification)
		}
		switch _, ok := n.simpleExpression.typ.(*file); {
		case ok && !param:
			p.w("&")
		default:
			defer p.w("%s", p.convert(n.isConst, n.literal, n.typ, t))
		}
		p.simpleExpression(n.simpleExpression, n.simpleExpression.typ, parens)
		return
	}

	if parens {
		p.w("(")
		defer p.w(")")
	}
	t2 := promote(n.simpleExpression.typ, n.rhs.typ)
	t3 := t2
	if n.rhs.isConst || n.rhs.literal != nil {
		t2 = n.simpleExpression.typ
		t3 = n.rhs.typ
	}
	p.simpleExpression(n.simpleExpression, t2, parens)
	switch n.relOp.ch {
	case '=':
		p.w(" == ")
	case NE:
		p.w(" != ")
	case '<':
		p.w(" < ")
	case LE:
		p.w(" <= ")
	case '>':
		p.w(" > ")
	case GE:
		p.w(" >= ")
	case IN:
		p.err(n.relOp, "internal error: %s", n.relOp.ch)
	default:
		p.err(n.relOp, "internal error: %s", n.relOp.ch)
	}
	p.simpleExpression(n.rhs, t3, parens)
}

func (p *project) convert(isConst bool, l literal, from, to typ) string {
	if from == to || isConst || l != nil || from.goType() == to.goType() {
		return ""
	}

	switch f := from.(type) {
	case *char:
		switch t := to.(type) {
		case *char:
			return ""
		default:
			panic(todo("%v -> %v: %T", from, to, t))
		}
	case *integer:
		switch t := to.(type) {
		case *integer:
			return ""
		case *subrange:
			p.w("%s(", t.goType())
			return ")"
		case *real:
			p.w("%s(", t.goType())
			return ")"
		default:
			panic(todo("%v -> %v: %T", from, to, t))
		}
	case *real:
		switch t := to.(type) {
		case *real:
			return ""
		default:
			panic(todo("%v -> %v: %T", from, to, t))
		}
	case *boolean:
		switch t := to.(type) {
		case *boolean:
			return ""
		default:
			panic(todo("%v -> %v: %T", from, to, t))
		}
	case *array:
		if to.canBeAssignedFrom(from) {
			if t, ok := to.(*array); ok && t.isString && l == nil {
				p.w("string(")
				return "[:])"
			}
			return ""
		}

		panic(todo("%v -> %v: %T", from, to, f))
	case *subrange:
		switch t := to.(type) {
		case *subrange:
			p.w("%s(", t.goType())
			return ")"
		case *integer:
			p.w("%s(", t.goType())
			return ")"
		case *real:
			p.w("%s(", t.goType())
			return ")"
		default:
			panic(todo("%v -> %v: %T", from, to, t))
		}
	default:
		panic(todo("%v -> %v: %T", from, to, f))
	}
}

func (p *project) simpleExpression(n *simpleExpression, t typ, parens bool) {
	if len(n.list) == 0 {
		defer p.w("%s", p.convert(n.isConst, n.literal, n.typ, t))
		if n.sign != nil {
			p.w("-")
		}
		p.term(n.term, n.term.typ)
		return

	}

	defer p.w("%s", p.convert(n.isConst, nil, n.typ, t))
	if parens {
		p.w("(")
		defer p.w(")")
	}
	if n.sign != nil {
		p.w("-")
	}
	t2 := t
	t3 := t
	if rhs := n.list[0]; len(n.list) == 1 && rhs.isConst || rhs.literal != nil {
		t2 = n.typ
		t3 = rhs.typ
	}
	p.term(n.term, t2)
	for _, v := range n.list {
		switch v.addOp.ch {
		case '+':
			p.w(" + ")
		case '-':
			p.w(" - ")
		case OR:
			p.w(" || ")
		default:
			p.err(v.addOp, "internal error: %s", v.addOp.ch)
		}
		p.term(v.term, t3)
	}
}

func (p *project) term(n *term, t typ) {
	if len(n.list) == 0 {
		defer p.w("%s", p.convert(n.isConst, n.literal, n.typ, t))
		p.factor(n.factor, n.factor.typ)
		return
	}

	defer p.w("%s", p.convert(n.isConst, n.literal, n.typ, t))
	if len(n.list) != 0 {
		p.w("(")
		defer p.w(")")
	}
	t2 := t
	t3 := t
	if rhs := n.list[0]; len(n.list) == 1 && rhs.isConst || rhs.literal != nil {
		t2 = n.typ
		t3 = rhs.typ
	}
	p.factor(n.factor, t2)
	for _, v := range n.list {
		switch v.mulOp.ch {
		case '*':
			p.w(" * ")
		case '/':
			p.w(" / ") //TODO adjust per operand types
		case DIV:
			p.w(" / ") //TODO adjust per operand types
		case MOD:
			p.w(" %% ")
		case AND:
			p.w(" && ")
		default:
			p.err(v.mulOp, "internal error: %s", v.mulOp.ch)
		}
		p.factor(v.factor, t3)
	}
}

func (p *project) factor(n *factor, t typ) {
	defer p.w("%s", p.convert(n.isConst, n.literal, n.typ, t))
	if n.unsignedConstant != nil {
		p.unsignedConstant(n.unsignedConstant)
		return
	}

	if n.functionDesignator != nil {
		p.functionDesignator(n.functionDesignator)
		return
	}

	if n.variable != nil {
		p.rVariable(n.variable)
		return
	}

	if n.expression != nil {
		p.expression(n.expression, n.expression.typ, true)
		return
	}

	p.w("!")
	p.factor(n.not, aBoolean)
}

func (p *project) functionDesignator(n *functionDesignator) {
	switch {
	case n.replace != "":
		p.w("%s", n.replace)
	default:
		p.identifier(n.identifier)
	}
	p.w("(")
	args := n.args
	for i, v := range n.list {
		p.expression(v, args[i], false)
		p.w(", ")
	}
	p.w(")")
}

func (p *project) unsignedConstant(n *unsignedConstant) {
	if n.unsignedNumber != nil {
		p.unsignedNumber(n.unsignedNumber)
		return
	}

	if n.str != nil {
		p.w("%s", n.literal.render())
		return
	}

	p.identifier(n.identifier)
}

func (p *project) unsignedNumber(n *unsignedNumber) {
	p.w("%s", n.literal.render())
}

func (p *project) rVariable(n *variable) {
	if n.identifier != nil {
		switch n.identifier.tok.src {
		case "sys_time", "sys_day", "sys_month",
			"sys_year":
			switch x := n.identifier.def.(type) {
			case *variableDeclaration:
				if x.isTLD {
					p.w("pas%s()", capitalize(goIdent(n.identifier.src)))
					return
				}
			}
		}
		p.identifier(n.identifier)
		return
	}

	if n.componentVariable != nil {
		p.rComponentVariable(n.componentVariable)
		return
	}

	p.rDeref(n.deref)
}

func (p *project) rDeref(n *variable) {
	p.rVariable(n)
	p.w(".%s()", n.typ.(*file).component.goType())
}

func (p *project) rComponentVariable(n *componentVariable) {
	if n.indexedVariable != nil {
		p.indexedVariable(n.indexedVariable)
		return
	}

	p.rFieldDesignator(n.fieldDesignator)
}

func (p *project) rFieldDesignator(n *fieldDesignator) {
	p.rVariable(n.variable)
	p.w(".%s", goIdent(n.ident.src))
	if n.field.isVariant {
		p.w("()")
	}
}

func (p *project) indexedVariable(n *indexedVariable) {
	p.rVariable(n.variable)
	dims := n.variable.typ.(*array).dims
	for i, v := range n.list {
		p.w("[")
		p.expression(v, v.typ, false)
		if x, ok := dims[i].(*subrange); ok && x.lo != 0 {
			p.w("%+d", -x.lo)
		}
		p.w("]")
	}
}

func (p *project) identifier(n *identifier) {
	_, isConst := n.def.(*constantDefinition)
	if !isConst && n.scope.isTLD && p.task.lib {
		p.w("%s.", p.task.rcvrName)
	}
	p.w("%s", goIdent(n.src))
}

func (p *project) procedureAndFunctionDeclarationPart(n *procedureAndFunctionDeclarationPart) {
	if n.procedureDeclaration != nil {
		p.procedureDeclaration(n.procedureDeclaration)
		return
	}

	if n.functionDeclaration != nil {
		p.functionDeclaration(n.functionDeclaration)
	}
}

func (p *project) functionDeclaration(n *functionDeclaration) {
	if n.forward != nil {
		return
	}

	switch {
	case p.task.lib:
		p.w("\n\nfunc (%s *%s) %s(", p.task.rcvrName, p.task.progTypeName, goIdent(n.functionHeading.ident.src))
	default:
		p.w("\n\nfunc %s(", goIdent(n.functionHeading.ident.src))
	}
	p.formalParameters(n.functionHeading.list)
	p.w(") (ret %s) {", n.functionHeading.typ.goType())
	p.block(n.block, false)
	p.w("\nreturn ret\n}")
}

func (p *project) formalParameters(list []*formalParameterSection) {
	for _, v := range list {
		var list []*tok
		prefix := ""
		switch {
		case v.valueParameterSpecification != nil:
			list = v.valueParameterSpecification.list
		case v.variableParameterSpecification != nil:
			list = v.variableParameterSpecification.list
			if _, ok := v.typ.(*file); !ok {
				prefix = "*"
			}
		}
		for i, v := range list {
			p.w("%s", goIdent(v.src))
			if i != len(list)-1 {
				p.w(", ")
			}
		}
		p.w(" %s%s", prefix, v.typ.goType())
		p.w(", ")
	}
}

func (p *project) procedureDeclaration(n *procedureDeclaration) {
	if n.forward != nil {
		return
	}

	switch {
	case p.task.lib:
		p.w("\n\nfunc (%s *%s) %s(", p.task.rcvrName, p.task.progTypeName, goIdent(n.procedureHeading.ident.src))
	default:
		p.w("\n\nfunc %s(", goIdent(n.procedureHeading.ident.src))
	}
	p.formalParameters(n.procedureHeading.list)
	p.w(") {")
	p.block(n.block, false)
	p.w("\n}")
}

func (p *project) variableDeclarationPart(n *variableDeclarationPart, tld bool) {
	if n == nil {
		return
	}

	if tld {
		if tld {
			switch {
			case p.task.lib:
				p.w("\n\ntype %s struct{", p.task.progTypeName)
				defer p.w("\n}")
			default:
				p.w("\n\nvar (")
				defer p.w("\n)")
			}
		}
		for _, v := range n.list {
			for _, w := range v.list {
				p.w("\n%s %s\t // %s", goIdent(w.src), strings.TrimLeft(v.typ.goType(), "*"), v.typ)
			}
		}
		return
	}

	for _, v := range n.list {
		var list []*tok
		for _, w := range v.list {
			if _, ok := v.used[w.src]; ok {
				list = append(list, w)
			}
		}
		if len(list) == 0 {
			continue
		}

		p.w("\nvar")
		for i, w := range list {
			if i != 0 {
				p.w(",")
			}
			p.w(" %s", goIdent(w.src))
		}
		p.w(" %s\t// %s", strings.TrimLeft(v.typ.goType(), "*"), v.typ)
	}
	p.w("\n")
}

func (p *project) typeDefinitionPart(n *typeDefinitionPart) {
	if n == nil {
		return
	}

	var recs []*typeDefinition
	p.w("\n\ntype (")
	for _, v := range n.list {
		switch v.typ.(type) {
		case *record:
			recs = append(recs, v)
			continue
		}

		p.w("\n\t%s %s\t// %s", goIdent(v.ident.src), v.typ.render(), v.typ)
	}
	p.w("\n)\n")
	for _, v := range recs {
		p.record(v)
	}
}

func (p *project) record(td *typeDefinition) {
	tn := goIdent(td.ident.src)
	p.w("\ntype %s %s\n", tn, td.typ.render())
	for _, v := range td.typ.(*record).variants {
		fn := v.name
		ft := v.typ.goType()
		switch {
		case v.off == 0:
			p.w("\n\nfunc (r %s) %s() %s { return *(*%[3]s)(unsafe.Pointer(&r.variant)) }", tn, fn, ft)
			p.w("\n\nfunc (r *%s) %s() *%s { return (*%[3]s)(unsafe.Pointer(&r.variant)) }", tn, p.lvalueName(fn), ft)
		default:
			p.w("\n\nfunc (r %s) %s() %s { return *(*%[3]s)(unsafe.Pointer(uintptr(unsafe.Pointer(&r.variant))+%d)) }", tn, fn, ft, v.off)
			p.w("\n\nfunc (r *%s) %s() *%s { return (*%[3]s)(unsafe.Pointer(uintptr(unsafe.Pointer(&r.variant))+%d)) }", tn, p.lvalueName(fn), ft, v.off)
		}
	}
}

func (p *project) lvalueName(s string) string { return "p" + capitalize(s) }

func (p *project) constantDefinitionPart(n *constantDefinitionPart) {
	if n == nil {
		return
	}

	p.w("\n\nconst (")
	for _, v := range n.list {
		p.w("\n\t%s = %s", goIdent(v.ident.src), v.literal.render())
	}
	p.w("\n)")
}

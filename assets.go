// Code generated by assets compiler. DO NOT EDIT.

package main

var (
	assets = map[string]string{
		"/changefile.ch": "@x 378\n@d othercases == others: {default for cases not listed explicitly}\n@y\n@d othercases == else {default for cases not listed explicitly}\n@z\n\n@x 426\n@!pool_name='TeXformats:TEX.POOL                     ';\n@y\n@!pool_name='tex.pool                                ';\n@z\n",
		"/rtl.go":        "// NOTE: This file (rtl.go) has a different license compared to all of the\n// other Go files in this repository.\n\n// ----------------------------------------------------------------------------\n//\n// No Copyright\n//\n// The person who associated a work with this deed has dedicated the work to\n// the public domain by waiving all of his or her rights to the work worldwide\n// under copyright law, including all related and neighboring rights, to the\n// extent allowed by law.\n//\n// You can copy, modify, distribute and perform the work, even for commercial\n// purposes, all without asking permission. See Other Information below.\n//\n// This license is acceptable for Free Cultural Works.\n//\n// Other Information\n//\n// In no way are the patent or trademark rights of any person affected by CC0,\n// nor are the rights that other persons may have in the work or in how the\n// work is used, such as publicity or privacy rights.\n//\n// Unless expressly stated otherwise, the person who associated a work with\n// this deed makes no warranties about the work, and disclaims liability for\n// all uses of the work, to the fullest extent permitted by applicable law.\n//\n// When using or citing the work, you should not imply endorsement by the\n// author or the affirmer.\n//\n// ----------------------------------------------------------------------------\n// Source of the above: https://creativecommons.org/publicdomain/zero/1.0/\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\t\"unsafe\"\n)\n\ntype memoryWord struct {\n\tvariant float32\n}\n\n/* CUT HERE */\n\nvar (\n\t_ error = pasError(0)\n\n\tisMain bool\n)\n\nconst (\n\tpasEndOfTeX pasError = -iota - 1\n\tpasFinalEnd\n)\n\nconst (\n\tstdioDev      = \"TTY:\"\n\tmodeNoIOPanic = \"/O\"\n)\n\nfunc origin(skip int) string {\n\tpc, fn, fl, _ := runtime.Caller(skip)\n\tfn = filepath.Base(fn)\n\tf := runtime.FuncForPC(pc)\n\tvar fns string\n\tif f != nil {\n\t\tfns = f.Name()\n\t\tif x := strings.LastIndex(fns, \".\"); x > 0 {\n\t\t\tfns = fns[x+1:]\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"%s:%d:%s\", fn, fl, fns)\n}\n\nfunc todo(s string, args ...interface{}) string { //TODO-\n\tswitch {\n\tcase s == \"\":\n\t\ts = fmt.Sprintf(strings.Repeat(\"%v \", len(args)), args...)\n\tdefault:\n\t\ts = fmt.Sprintf(s, args...)\n\t}\n\tpc, fn, fl, _ := runtime.Caller(1)\n\tf := runtime.FuncForPC(pc)\n\tvar fns string\n\tif f != nil {\n\t\tfns = f.Name()\n\t\tif x := strings.LastIndex(fns, \".\"); x > 0 {\n\t\t\tfns = fns[x+1:]\n\t\t}\n\t}\n\tr := fmt.Sprintf(\"%s:%d:%s: TODOTODO %s\", fn, fl, fns, s) //TODOOK\n\tfmt.Fprintf(os.Stdout, \"%s\\n\", r)\n\tos.Stdout.Sync()\n\treturn r\n}\n\nfunc trc(s string, args ...interface{}) string { //TODO-\n\tswitch {\n\tcase s == \"\":\n\t\ts = fmt.Sprintf(strings.Repeat(\"%v \", len(args)), args...)\n\tdefault:\n\t\ts = fmt.Sprintf(s, args...)\n\t}\n\t_, fn, fl, _ := runtime.Caller(1)\n\tr := fmt.Sprintf(\"%s:%d: TRC %s\", fn, fl, s)\n\tfmt.Fprintf(os.Stdout, \"%s\\n\", r)\n\tos.Stdout.Sync()\n\treturn r\n}\n\ntype pasError int\n\nfunc (err pasError) Error() string { return fmt.Sprintf(\"%T(%[1]d)\", err) }\n\nfunc pasJumpOut() { panic(pasEndOfTeX) }\n\nfunc abs(n float32) float32       { return float32(math.Abs(float64(n))) } //TODO check the Pascal definition.\nfunc chr(i int32) byte            { return byte(i) }\nfunc odd(i int32) bool            { return i&1 != 0 }\nfunc pasSysDay() int32            { return int32(time.Now().Day()) }\nfunc pasSysMonth() int32          { return int32(time.Now().Month()) }\nfunc pasSysTime() int32           { return int32(time.Now().Hour()*60 + time.Now().Minute()) }\nfunc pasSysYear() int32           { return int32(time.Now().Year()) }\nfunc read(args ...interface{})    { args[0].(*pasFile).read(args[1:], false) }\nfunc readLn(args ...interface{})  { args[0].(*pasFile).read(args[1:], true) }\nfunc round(n float32) int32       { return int32(math.Round(float64(n))) } //TODO check the Pascal definition.\nfunc write(args ...interface{})   { args[0].(*pasFile).write(args[1:], false) }\nfunc writeLn(args ...interface{}) { args[0].(*pasFile).write(args[1:], true) }\n\nfunc iabs(n int32) int32 {\n\tif n >= 0 {\n\t\treturn n\n\t}\n\n\tif n == math.MinInt32 {\n\t\tpanic(\"overflow\")\n\t}\n\n\treturn -n\n}\n\nfunc setString(dst []byte, src string) {\n\tfor i := range dst {\n\t\tdst[i] = ' '\n\t}\n\tcopy(dst, src)\n}\n\ntype pasFile struct {\n\t*ioFile\n}\n\nfunc (f *pasFile) byte() byte { return f.component[0] }\n\nfunc (f *pasFile) memoryWord() memoryWord {\n\tif g, e := uintptr(f.componentSize), unsafe.Sizeof(memoryWord{}); g != e { //TODO-\n\t\tpanic(todo(\"invalid component: got %v, expected %v (%q)\", g, e, f.name))\n\t}\n\n\treturn *(*memoryWord)(unsafe.Pointer(&f.component))\n}\n\nfunc (f *pasFile) pMemoryWord() *memoryWord {\n\tif g, e := uintptr(f.componentSize), unsafe.Sizeof(memoryWord{}); g != e { //TODO-\n\t\tpanic(todo(\"invalid component: got %v, expected %v (%q)\", g, e, f.name))\n\t}\n\n\treturn (*memoryWord)(unsafe.Pointer(&f.component))\n}\n\nfunc break1(f *pasFile)                      { /* nop */ }\nfunc breakIn(f *pasFile, b bool)             { /* nop */ }\nfunc close(f *pasFile)                       { f.close() }\nfunc eof(f *pasFile) bool                    { return f.ioFile.eof }\nfunc eoln(f *pasFile) bool                   { return f.ioFile.eoln() }\nfunc erstat(f *pasFile) int32                { return f.erstat }\nfunc get(f *pasFile)                         { f.get() }\nfunc put(f *pasFile)                         { f.put() }\nfunc reset1(f *pasFile, name, mode string)   { reset(f, 1, name, mode) }\nfunc reset4(f *pasFile, name, mode string)   { reset(f, 4, name, mode) }\nfunc rewrite1(f *pasFile, name, mode string) { rewrite(f, 1, name, mode) }\nfunc rewrite4(f *pasFile, name, mode string) { rewrite(f, 4, name, mode) }\n\n// [0] page 87\n//\n// Reset (F) initiates inspection (reading) of F by placing the file at its\n// beginning. If F is not empty, the value of the first component of F is\n// assigned to F and eof (F) becomes false.\nfunc reset(f *pasFile, componentSize int, name, mode string) {\n\tname = strings.TrimRight(name, \" \")\n\tif !strings.Contains(mode, modeNoIOPanic) {\n\t\tpanic(fmt.Errorf(\"unsupported file mode: %q (%q)\", mode, name))\n\t}\n\n\tf.close()\n\tf.ioFile = nil\n\tif name == stdioDev {\n\t\tswitch {\n\t\tcase isMain:\n\t\t\tf.ioFile = &ioFile{\n\t\t\t\teof:           false,\n\t\t\t\terstat:        0,\n\t\t\t\tcomponentSize: componentSize,\n\t\t\t\tname:          os.Stdin.Name(),\n\t\t\t\tin:            os.Stdin, //TODO bufio\n\t\t\t}\n\t\t\treturn\n\t\tdefault:\n\t\t\tpanic(todo(\"\"))\n\t\t}\n\t}\n\n\tg, err := os.Open(name)\n\tswitch {\n\tcase err != nil:\n\t\tpanic(todo(\"\", name, mode, err))\n\tdefault:\n\t\tswitch fi, err := g.Stat(); {\n\t\tcase err != nil:\n\t\t\tpanic(fmt.Errorf(\"cannot stat opened file: %v (%q)\", err, name))\n\t\tcase fi.Size() == 0:\n\t\t\tpanic(todo(\"\"))\n\t\tdefault:\n\t\t\tf.ioFile = &ioFile{\n\t\t\t\teof:           false,\n\t\t\t\terstat:        0,\n\t\t\t\tcomponentSize: componentSize,\n\t\t\t\tname:          name,\n\t\t\t\tin:            g, //TODO bufio\n\t\t\t}\n\t\t\tif _, err := io.ReadFull(f.ioFile.in, f.ioFile.component[:f.ioFile.componentSize]); err != nil {\n\t\t\t\tf.ioFile.eof = true\n\t\t\t\tf.ioFile.erstat = 1\n\t\t\t\tf.ioFile.in.Close()\n\t\t\t}\n\t\t}\n\t}\n}\n\n// [0] page 88.\n//\n// Rewrite (F) initiates generation (writing) of the file F. The current value\n// of F is replaced with the empty file. Eof(F) becomes true, and a new file\n// may be written.\nfunc rewrite(f *pasFile, componentSize int, name, mode string) {\n\tname = strings.TrimRight(name, \" \")\n\tif !strings.Contains(mode, modeNoIOPanic) {\n\t\tpanic(fmt.Errorf(\"unsupported file mode: %q\", mode))\n\t}\n\n\tf.close()\n\tf.ioFile = nil\n\tif name == stdioDev {\n\t\tswitch {\n\t\tcase isMain:\n\t\t\tf.ioFile = &ioFile{\n\t\t\t\teof:           true,\n\t\t\t\terstat:        0,\n\t\t\t\tcomponentSize: componentSize,\n\t\t\t\tname:          os.Stdout.Name(),\n\t\t\t\tout:           os.Stdout, //TODO bufio\n\t\t\t}\n\t\t\treturn\n\t\tdefault:\n\t\t\tpanic(todo(\"\"))\n\t\t}\n\t}\n\n\tg, err := os.Create(name)\n\tif err != nil {\n\t\tpanic(todo(\"\", name, mode))\n\t}\n\n\tf.ioFile = &ioFile{\n\t\teof:           true,\n\t\terstat:        0,\n\t\tcomponentSize: componentSize,\n\t\tname:          name,\n\t\tout:           g, //TODO bufio\n\t}\n}\n\ntype ioFile struct {\n\tcomponent     [unsafe.Sizeof(memoryWord{})]byte\n\terstat        int32\n\tin            io.ReadCloser\n\tcomponentSize int\n\tname          string\n\tout           io.WriteCloser\n\n\teof bool\n\teol bool\n}\n\nfunc (f *ioFile) close() {\n\tif f == nil {\n\t\treturn\n\t}\n\n\tif f.in != nil {\n\t\tif err := f.in.Close; err != nil {\n\t\t\tf.erstat = 1\n\t\t}\n\t\tf.eof = true\n\t\tf.in = nil\n\t}\n\n\tif f.out != nil {\n\t\tif err := f.out.Close; err != nil {\n\t\t\tf.erstat = 1\n\t\t}\n\t\tf.eof = false\n\t\tf.in = nil\n\t}\n}\n\n// [0] page 88\n//\n// Read (F, X) (for X, a variable) is equivalent to\n//\n// \tbegin\n// \t\tX := F^; Get(F)\n// \tend\n//\n// Read (F, V1, ... , Vn) is equivalent to the statement\n//\n//\tbegin Read(F,V1); ... ;Read(F,Vn) end\nfunc (f *ioFile) read(args []interface{}, nl bool) {\n\tf.eol = false\n\tfor len(args) != 0 {\n\t\targ := args[0]\n\t\targs = args[1:]\n\t\tif w, ok := getWidth(&args); ok {\n\t\t\tpanic(todo(\"\", w))\n\t\t}\n\n\t\tswitch x := arg.(type) {\n\t\tcase *byte:\n\t\t\t*x = f.component[0]\n\t\tdefault:\n\t\t\tpanic(fmt.Errorf(\"unsupported read variable type: %T (%q)\", x, f.name))\n\t\t}\n\t\tf.get()\n\t}\n\tif !nl {\n\t\treturn\n\t}\n\n\t// [0] page 92\n\t//\n\t// ReadLn(F) skips to the beginning of the next line of the textfile F (F^\n\t// becomes the first character of the next line).\n\tfor !f.eof && f.component[0] != '\\n' {\n\t\tf.get()\n\t}\n\tif !f.eof {\n\t\tf.get()\n\t}\n}\n\n// [0] page 88\n//\n// Write(F, E) (for E, an expresion) is equivalent to\n//\n// \tbegin\n// \t\tF^ := E; Put(F)\n// \tend\n// Write (F, E1, ... , En) is equivalent to the statement\n//\n//\tbegin Write(F,E1); ... ; Write(F,En) end\nfunc (f *ioFile) write(args []interface{}, nl bool) {\n\tfor len(args) != 0 {\n\t\targ := args[0]\n\t\targs = args[1:]\n\t\tif w, ok := getWidth(&args); ok {\n\t\t\tpanic(todo(\"\", w))\n\t\t}\n\n\t\tvar err error\n\t\tswitch x := arg.(type) {\n\t\tcase string:\n\t\t\t_, err = f.out.Write([]byte(x))\n\t\tcase byte:\n\t\t\tf.component[0] = x\n\t\t\tf.put()\n\t\tdefault:\n\t\t\tpanic(fmt.Errorf(\"unsupported write variable type: %T (%q)\", x, f.name))\n\t\t}\n\t\tif err != nil {\n\t\t\tpanic(fmt.Errorf(\"write I/O error: %v (%q)\", err, f.name))\n\t\t}\n\t}\n\t// [0] page 92\n\t//\n\t// Writeln (F) terminates the current line of the textfile F.\n\tif nl {\n\t\tf.write([]interface{}{\"\\n\"}, false)\n\t}\n}\n\n// [0] page 88\n//\n// Get(F) advances the file to the next component and assigns the value of this\n// component to the buffer variable F^. If no next component exists, then\n// eof(F) becomes true, and F^ becomes undefined. The effect of Get (F) is an\n// error if eof(F) is true prior to its execution or if F is being generated.\nfunc (f *ioFile) get() {\n\tif f.eof {\n\t\tpanic(fmt.Errorf(\"get called at eof: %s\", f.name))\n\t}\n\n\tf.eol = false\n\tif _, err := io.ReadFull(f.in, f.component[:f.componentSize]); err != nil {\n\t\tf.eof = true\n\t\tf.erstat = 1\n\t\tf.in.Close()\n\t}\n}\n\n// [0] page 88\n//\n// Put(F) appends the value of the buffer variable F^ to the file F. The effect\n// is an error unless prior to execution the predicate eof(F) is true. eof(F)\n// remains true, and F^ becomes undefined. Put(F) is an error if F is being\n// inspected.\nfunc (f *ioFile) put() {\n\tif !f.eof {\n\t\tpanic(fmt.Errorf(\"put called not at eof: %s\", f.name))\n\t}\n\n\tif _, err := f.out.Write(f.component[:f.componentSize]); err != nil {\n\t\tpanic(fmt.Errorf(\"put I/O error: %v (%q)\", err, f.name))\n\t}\n}\n\n// [0] page 92\n//\n// Eoln(F)\n//\n// a Boolean function indicating whether the end of the current line in the\n// textfile F has been reached. (If true, F^ corresponds to the position of a\n// line separator, but F^ is a blank.)\nfunc (f *ioFile) eoln() bool {\n\tif f.eol {\n\t\treturn true\n\t}\n\n\tif f.component[0] != '\\n' {\n\t\treturn false\n\t}\n\n\tf.component[0] = ' '\n\tf.eol = true\n\treturn true\n}\n\ntype vaWidth int\n\nfunc getWidth(args *[]interface{}) (int, bool) {\n\ts := *args\n\tif len(s) == 0 {\n\t\treturn 0, false\n\t}\n\n\tx, ok := s[0].(vaWidth)\n\tif !ok {\n\t\treturn 0, false\n\t}\n\n\t*args = s[1:]\n\treturn int(x), true\n}\n",
	}
)
